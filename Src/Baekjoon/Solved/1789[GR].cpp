#pragma warning(disable : 4996)
#include <math.h>
#include <stdio.h>

/* 가장 빠른 풀이 : O(1) */
int main(int argc, char* argv[]) {
  long long S;
  scanf("%lld", &S);  // N은 N의 최댓값

  printf("%lld", (long long)((sqrt(1 + 8 * S) - 1) / 2));

  return 0;
}

/* 또 다른 풀이1 : O(logN) */
#pragma warning(disable : 4996)
#include <stdio.h>

int main(int argc, char* argv[]) {
  long long S;
  scanf("%lld", &S);
  long long N;  // N의 최댓값

  for (N = 1; !(N * (N + 1) / 2 <= S && S <= N * (N + 3) / 2); N++) {
  }

  printf("%lld", N);

  return 0;
}

/*
S를 unsigned int로 선언하면, 제곱근 안에 8 * S를 하는 과정에서 오버플로우가
발생한다. 따라서, long long으로 선언해주어야 한다.
*/

/*
종이에 풀이 적음. O(1)풀이의 경우, 이차 방정식 이용.

[접근방식]
자연수 중 가장 작은값인 1부터 차례대로 대입한다.
작은 숫자의 개수가 많을수록, N은 최대가 된다. (그리디 방식)

[알아 둘 내용]
Unsigned int의 값이 4294967295이다.

[접근]
#. 2의 경우
1[1]
2[3] -> [1] + 2 = 3이므로 불가.

따라서, 1개

#. 3의 경우
1[1]
2[3] -> [1] + 2 = 3이므로 가능.

따라서, 2개

#. 4의 경우
1[1]
2[3]
3[6] -> [3] + 3 = 6이므로 불가.

따라서, 2개

#. 5의 경우
1[1]
2[3]
3[6] -> [3] + 3 = 6이므로 불가.

따라서, 2개

#. 6의 경우
1[1]
2[3]
3[6] -> [3] + 3 = 6이므로 가능.

따라서, 3개

...
===============================
1+...+(n) ~ 1+...+(n)+(n+1)-1 =
1+...+(n) ~ 1+...+(n)+(n) =
n*(n+1)/2 ~ n*(n+3)/2

1 : 001 ~ 002
2 : 003 ~ 005
3 : 006 ~ 009
4 : 010 ~ 014
...

*/
